<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBJECTS</title>

    <script>

        /*

        for eg let car be an OBJECt

        Properties

        car.name = Fiat
        car.model = 500
        car.color = white

        -------------------------------------------------------


        Methods

        car.start()
        car.drive()
        car.brake()

        OBJECTS are variables tooo. but objects contain many values

        */

        // const car = {
        //     type:"Lamborgini",
        //     color:"blue",
        //     fuel:"petrol",
        // }

        // here car is object and type,color and fuel are its properties.

        // it is common practice to declare objects with const keyword

        // HOW TO DEFINE A JAVASCRIPT OBJECT ?

        /*
            1. Object literal
            2. new keyword
            3. Object Constructor
        
        */

        // Object literal

        // {firstnName : "John", lastName : "Doe", age: 50 , eyeColor: "darkblue"}

        // // or

        // const person =  {
        //     firstnName : "John", 
        //     lastName : "Doe", 
        //     age: 50 , 
        //     eyeColor: "darkblue"
        // };

        // this example create an empty JS object and add values into it

        // const person2 = {};

        // person2.firstnName = "John"
        // person2.lastName = "Doe"
        // person2.age = 23
        // person2.eyeColor = "dark-brown"

        // // NEW KEYWORD

        // const person3 = new Object();

        // person3.firstnName = "James"
        // person3.lastName = "Whiltooth"
        // person3.age = 32
        // person3.eyeColor = "dark-green"

        // accessing the properties

        /*
        objectName.propertyName;
        objectName['propertyName'];
        */

        // JS OBJECT METHODS

        /*
        
        Methods are actions thazt can be performed on the objects

        Methods are function definitions stored as property values

        Objects are containers for properties and methods.
        Properties are named values.
        Methods are functions stored as properties.
        Properties can be primitive values, functions and other objects.

        IMMUTABLE - PRIMITIVE VALUES ARE ALWAYS IMMUTABLE - they are hardcoded and can't be changed

        for example

        var x = 3.14;

        here the value of x can be changed but the values of 3.14 can't be changed.

        */

        // --------------------------------------------------------------------------------------

        // What Does Mutable Mean?
        /* 
           In programming, mutability refers to the ability to change the state or contents of an object after 
           it has been created. An object that can be changed after its creation is called mutable, whereas an 
           object that cannot be changed is called immutable.

           ------------------------------------------------------------------------------------------------------

           JavaScript Objects are Mutable

           In JavaScript, objects are mutable. This means that once you create an object, you can change, add, 
           or delete properties of that object.

           ------------------------------------------------------------------------------------------------------

           Why Mutability is Important?

              ---- Side Effects: If you pass an object to a function and that function modifies the object, those changes 
              will be visible outside the function. This is because objects are passed by reference.

              ---- Performance: Modifying an object is generally more efficient than creating a new object, especially 
              if the object is large or if you need to make many changes.

        */

        // let user = {
        //     name: "Alice",
        //     age: 25
        // };

        // function updatePerson(userObj) {
        //    userObj.age = 30;
        // };

        // updatePerson(user);
        // console.log(user.age);

        // console.log(user);

        /* In this example, the updatePerson function modifies the age property 
           of the person object. Because objects are passed by reference, the 
           change is reflected outside the function. */
        
        // const x = user;

        /* The object x is not a copy of person. The object x is person.

        The object x and the object person share the SAME MEMMORY ADDRESS.*/

        // Change Age in both

        // x.age = 10;

        // Delete

        /* The delete keyword deletes both the value of the property and the property itself.

           After deletion, the property cannot be used before it is added back again. */

        // NESTED OBJECTS

            // myObj = {
            //     name: "John",
            //     age: 30,
            //     myCars: {
            //         car1: "Ford",
            //         car2: "BMW",
            //         car3: "Fiat"
            //     }
            // }

            // myObj.myCars.car2;
        

    // Displaying Object Properties

    // Create an Object

    // const person = {
    //     name: "John",
    //     age: 30,
    //     city: "New York"
    // };

    // Display Properties

    // document.getElementById("demo").innerHTML = person.name + "," + person.age + "," + person.city;

    // // Displaying Object Properties in a loop

    // // let text = "";
    // //     for (let x in person) {
    // //         text += person[x] + " ";
    // //     };

    // // Display the Text
    // document.getElementById("demo").innerHTML = text;

    /*

    You must use person[x] in the loop.

    person.x will not work (Because x is the loop variable).
    
    */

    // Using Object.values()

        // Create an Array
        // const myArray = Object.values(person);

        // // Display the Array
        // document.getElementById("demo").innerHTML = myArray;

    // Using Object.entries()

    // Object.entries() makes it simple to use objects in loops:

    // const fruits = { Bananas: 300, Oranges: 200, Apples: 500 };

    //     let text = "";
    //     for (let [fruit, value] of Object.entries(fruits)) {
    //         text += fruit + ": " + value + "<br>";
    //     }
    
    // Using JSON.stringify()

    /* JavaScript objects can be converted to a string with JSON method JSON.stringify().

       JSON.stringify() is included in JavaScript and supported in all major browsers.

       The result will be a string written in JSON notation:

    ---------{ "name": "John", "age": 50, "city": "New York" } */

        // // Stringify Object
        // let myString = JSON.stringify(person);

        // // Display String
        // document.getElementById("demo").innerHTML = myString;


        // ---------------------------------------------------------------------------------

        // Javascript Object Constructors

        /*
        -- Sometimes we need to create objects of the same type.
        -- to create objects of the same type we use a object constructor function,
        -- it considered a good practice to name constructor functions with uppercase
        first letter.
        */

        // function Flower(type, color, price){
        //     this.typeName = type;
        //     this.flowerColor = color;
        //     this.flowerPrice = price;
        //     this.flowerAvailability = "Available";
        //      // --------------- for giving default values.
        // }

        // in this constructor function, this  has no value.
        // the value of this will become the new object when a new object is created.

        // ---- creating similar objects.

        // const flowerOne = new Flower( 'Rose', 'Red', '40');
        // const flowerTwo = new Flower( 'Lotus', 'Pink', '45');
        // const flowerThree = new Flower( 'Chembaruthi', 'White', '55');

        // console.log(flowerTwo);

        // adding property to an object

        // flowerTwo.terrain = "water"; // the property is added only to flowerTwo and not any other flower objects.

        // console.log(flowerTwo);

        // Flower.discount = 'Available'; // but this won't work
        // console.log(Flower);

        // to add a new property you must add it to the constructor 
        // function prototype.

        // Flower.prototype.discount = "Available";
        // console.log(Flower);

        // CONSTRUCTOR FUNCTION METHODS

        // function Flower(type, color, price){
        //     this.typeName = type;
        //     this.flowerColor = color;
        //     this.flowerPrice = price;
        //     this.flowerAvailability = "Available";
        //     this.sentece = function(){
        //         return this.typeName+ " is " + this.flowerColor;
        //     }
        // };


        // Adding a method to created object is easy.

        // flowerOne.changeName = function(nameType){
        //     this.type = nameType;
        // };

        // console.log(flowerOne);
        // console.log(flowerTwo);

        // -------------------------------------------------------------------------------


        //  Adding a method to a constructor

        // Flower.changeName = function(typeName){
        //     this.type = typeName;
        // }

        // flowerOne.changeName('lily');

        // Flower.prototype.changeName = function(typeName){
        //     this.type = typeName;
        // }

        // flowerTwo.changeName('sunflower');

        // console.log(flowerTwo);

        // console.log(flowerOne);
        

        // var obj1 = new Object();
        // var obj2 = {};
        // var objj3 = Object.create(null); // it needs a template object if there is no template object use null

        // var hero = Object.create(null);
        // //hero.title = "Ironman";
        // Object.defineProperty(hero,"title", {configurable:true, value :"Ironman", writable:true, enumerable:true})
        // console.log(hero.title); //Ironman
        // hero.title = "Iron Monger";
        // console.log(hero.title); // nochange still Ironman ---- whrn it was not writtable and enurable false



        // --- What if i need to change this
        // --- writable - true then it can be modified
        // --- if enurable is false - which is defualt then it can't be iterated.

        // let avenger = {
        //     title:"Ironman",
        //     power:6,
        //     firstnName:"Tony",
        //     lastName:"Stark",
        //     city:"New York"
        // }
        // // for(let prop in avenger){
        // //     console.log(prop)
        // // }

        // for(let prop in hero){
        //     console.log(prop);
        // }

        // Object.defineProperty(hero,"title", { value :"Hulk", writable:false, enumerable:false}) // non writtable and non dicoverable
        // console.log(hero.title); //??
        // hero.title = "Joker";
        // console.log(hero.title); // ??

        // for(let prop in hero){
        //     console.log(prop)
        // };
        // console.log("###############");

        // it says it can't be redefined

        // use configarable

        // Object.defineProperty


        // ==============================================================================================

        // ------------------------------------OBJECTS ADVANCED------------------------------------------


        // Methods for Defining JavaScript Objects


        // Using an Object Literal

        // ---- An object literal is a list of property names:values inside curly braces {}.

        {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};

// ----------------------------------------------------------------------------------------

    // Using the new Keyword

    // Create an Object

    const person = {};

    // Add Properties
    person.firstName = "John";
    person.lastName = "Doe";
    person.age = 50;
    person.eyeColor = "blue";

    // Create an Object
    const person = new Object();

    // Add Properties
    person.firstName = "John";
    person.lastName = "Doe";
    person.age = 50;
    person.eyeColor = "blue";


// -------------------------------------------------------------------------------------------------------------



    // Using an Object Constructor

// function Person(first, last, age, eyecolor) {
//   this.firstName = first;
//   this.lastName = last;
//   this.age = age;
//   this.eyeColor = eyecolor;
//   this.nationality = "English";
// }


// -------------------------------------------------------------------------------------------------------------
// Using Object.assign()
// Using Object.create()
// Using Object.fromEnties()

// --------------------------------------------------------------------------------------------------------------

// Javascript Object Methods

// 1. GERNERAL METHODS

// Copies properties from a source object to a target object
Object.assign(target, source)

// --The Object.assign() method copies properties from one or more source objects to a target object.

// Create Target Object
const person1 = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  eyeColor: "blue"
};

// Create Source Object
const person2 = {firstName: "Anne",lastName: "Smith"};

// Assign Source to Target
Object.assign(person1, person2); // the outut will be that target object values will be repaced be the source object elements


// -----------------------------------------------------------------------------------------------------------



// Creates an object from an existing object
Object.create(object)

// Returns an array of the key/value pairs of an object
Object.entries(object)

/*

`Object.entries()` is a method in JavaScript that returns an array of a given object's own enumerable 
string-keyed property `[key, value]` pairs. This method is useful for converting objects into arrays, 
which can then be manipulated using array methods.

- `obj`: The object whose own enumerable string-keyed property `[key, value]` pairs are to be returned.


The `Object.entries()` method takes an object and returns an array of arrays. Each inner array has two elements: 
-------------the first element is the property key, and 
-------------the second element is the property value.

*/

// Example 1: Basic Usage


const obj = {
  a: 1,
  b: 2,
  c: 3
};

const entries = Object.entries(obj);
console.log(entries);

// Output: [['a', 1], ['b', 2], ['c', 3]]


// Example 2: Iterating Over Entries

// You can use `Object.entries()` in combination with `for...of` loop to iterate over an object's key-value pairs:


const objOne = {
  a: 1,
  b: 2,
  c: 3
};

for (const [key, value] of Object.entries(objOne)) {
  console.log(`${key}: ${value}`);
}
// Output:
// a: 1
// b: 2
// c: 3

// Example 3: Converting Object to Map

// Since `Map` objects also use key-value pairs, you can easily convert an object to a `Map` using `Object.entries()`:


const objTWo = {
  a: 1,
  b: 2,
  c: 3
};

const map = new Map(Object.entries(obj));
console.log(map);
// Output: Map(3) { 'a' => 1, 'b' => 2, 'c' => 3 }


// Example 4: Filtering Object Properties

// You can use `Object.entries()` to filter an object’s properties:

const objThree = {
  a: 1,
  b: 2,
  c: 3
};

const filteredEntries = Object.entries(obj).filter(([key, value]) => value > 1);
console.log(filteredEntries);
// Output: [['b', 2], ['c', 3]]

const filteredObj = Object.fromEntries(filteredEntries);
console.log(filteredObj);
// Output: { b: 2, c: 3 }

// Example 5: Handling Nested Objects

// When dealing with nested objects, `Object.entries()` will only convert the top-level properties. 
// You need to use a recursive approach to convert nested objects.


const nestedObj = {
  a: 1,
  b: { x: 10, y: 20 },
  c: 3
};

const entriesOne = Object.entries(nestedObj);
console.log(entries);
// Output: [['a', 1], ['b', { x: 10, y: 20 }], ['c', 3]]


/// Summary

/*
- `Object.entries()` is useful for converting objects into arrays of key-value pairs.
- It can be combined with array methods and loops for various operations like iteration, filtering, and mapping.
- The method works on the object's own enumerable string-keyed properties.
- Nested objects require additional handling if you need to deeply convert them.
*/

// ------------------------------------------------------------------------------------------------------------------------

// Creates an object from a list of keys/values
Object.fromEntries()

const fruits = [
  ["apples", 300],
  ["pears", 900],
  ["bananas", 500]
];

const myObj = Object.fromEntries(fruits);

{
  apples: 300,
  pears: 900,
  bananas: 500
}

/*

----- The fruits array contains three inner arrays: ["apples", 300], ["pears", 900], and ["bananas", 500].
----- When Object.fromEntries(fruits) is called, it converts these inner arrays into key-value pairs of an object.
----- The resulting object, myObj, will have properties with the keys "apples", "pears", and "bananas", and the 
corresponding values 300, 900, and 500.

*/

// --------------------------------------------------------------------------------------------------------------------------------------


// Returns an array of the keys of an object
Object.keys(object)

// ---------------------------------------------------------------------------------------------------------------------------------------

// Returns an array of the property values of an object
Object.values(object)

const person = {
  name: 'John',
  age: 30,
  city: 'New York'
};

const values = Object.values(person);
console.log(values);

// Output: ['John', 30, 'New York']

// Practical usage 

const orders = {
  order1: 200,
  order2: 450,
  order3: 130,
  order4: 300
};

// Get the total value of all orders
const orderValues = Object.values(orders);
const totalValue = orderValues.reduce((acc, value) => acc + value, 0);

console.log(totalValue);
// Output: 1080




// ---------------------------------------------------------------------------------------------------------------------------------


// Groups object elements according to a function
Object.groupBy(object, callback)



// ------------------------------------------------------------------------------------------------

// 2. PROPERY MANAGEMENT METHODS

// Adding or changing an object property
Object.defineProperty(object, property, descriptor)

// Adding or changing object properties
Object.defineProperties(object, descriptors)

// Accessing a Property
Object.getOwnPropertyDescriptor(object, property)

// Accessing Properties
Object.getOwnPropertyDescriptors(object)

// Returns all properties as an array
Object.getOwnPropertyNames(object)

// Accessing the prototype
Object.getPrototypeOf(object)

// 3. OBJECT PROTECTION METHODS

// Prevents re-assignment
const car = {type:"Fiat", model:"500", color:"white"};

// Prevents adding object properties
Object.preventExtensions(object)

// Returns true if properties can be added to an object
Object.isExtensible(object)

// Prevents adding and deleting object properties
Object.seal(object)

// Returns true if object is sealed
Object.isSealed(object)

// Prevents any changes to an object
Object.freeze(object)

// Returns true if object is frozen
Object.isFrozen(object)

// ---------------------------------------------------------------------------------------------------------------

// ----- Using const


/*
   The most common way to protect an object from being changed is by using the const keyword.

    With const you can not re-assign the object, but you can still change the value of a property, 
    delete a property or create a new property.

*/

// -------- PROTOTYPE INHERITENCE 

/* All JavaScript objects inherit properties and methods from a prototype:

-------- Date objects inherit from Date.prototype
-------- Array objects inherit from Array.prototype
-------- Person objects inherit from Person.prototype
-------- The Object.prototype is on the top of the prototype inheritance chain:

Date objects, Array objects, and Person objects inherit from Object.prototype.*/

// ----------------------- explanation

/*

In JavaScript, when we say that Date objects, Array objects, and Person objects (assuming Person is a user-defined constructor function) 
inherit from `Object.prototype`, it means that these objects are part of the prototype chain that ultimately links back 
to `Object.prototype`. This is a fundamental aspect of JavaScript's prototype-based inheritance.


1. **Object.prototype**:
   - `Object.prototype` is the top of the prototype chain. It provides default properties and methods that are available to all objects in JavaScript, such as `.toString()`, `.hasOwnProperty()`, etc.
   - When you create a new object, it inherits properties and methods from `Object.prototype` by default.

2. **Prototype Chain**:
   - The prototype chain is a mechanism by which objects inherit properties and methods from other objects. When you access a property or method on an object, JavaScript will look up the prototype chain to find it.
   - For example, if you call `arr.toString()` on an array `arr`, JavaScript first looks for the `toString` method on the array itself. If it's not found, it looks up the chain to `Array.prototype`, and then to `Object.prototype`.

3. **Date, Array, and Person Prototypes**:
   - **Date objects** inherit from `Date.prototype`, which in turn inherits from `Object.prototype`.
   - **Array objects** inherit from `Array.prototype`, which in turn inherits from `Object.prototype`.
   - **Person objects** (assuming a constructor function `Person`) inherit from `Person.prototype`, which in turn inherits from `Object.prototype`.

// Example of a Person constructor function

*/

function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Creating instances of different types
let date = new Date();
let array = [1, 2, 3];
let person = new Person('John', 30);

console.log(date.toString());  // Inherited from Date.prototype, which inherits from Object.prototype
console.log(array.toString()); // Inherited from Array.prototype, which inherits from Object.prototype
console.log(person.toString()); // Inherited from Object.prototype (default toString method)

/*
In this example:
- `date.toString()` is found on `Date.prototype`.
- `array.toString()` is found on `Array.prototype`.
- `person.toString()` is found on `Object.prototype` because `Person.prototype` does not define a `toString` method.

Thus, the statement that Date objects, Array objects, and Person objects inherit from `Object.prototype` 
emphasizes that all objects in JavaScript share a common ancestor, `Object.prototype`, which provides 
fundamental methods and properties used across all objects.

--------  The JavaScript prototype property allows you to add new properties to object constructors
--------  The JavaScript prototype property also allows you to add new methods to objects constructors

*/
        




        


    </script>
</head>
<body>
    
</body>
</html>