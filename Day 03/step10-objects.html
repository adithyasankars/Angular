<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBJECTS</title>

    <script>

        /*

        for eg let car be an OBJECt

        Properties

        car.name = Fiat
        car.model = 500
        car.color = white

        -------------------------------------------------------


        Methods

        car.start()
        car.drive()
        car.brake()

        OBJECTS are variables tooo. but objects contain many values

        */

        // const car = {
        //     type:"Lamborgini",
        //     color:"blue",
        //     fuel:"petrol",
        // }

        // here car is object and type,color and fuel are its properties.

        // it is common practice to declare objects with const keyword

        // HOW TO DEFINE A JAVASCRIPT OBJECT ?

        /*
            1. Object literal
            2. new keyword
            3. Object Constructor
        
        */

        // Object literal

        // {firstnName : "John", lastName : "Doe", age: 50 , eyeColor: "darkblue"}

        // // or

        // const person =  {
        //     firstnName : "John", 
        //     lastName : "Doe", 
        //     age: 50 , 
        //     eyeColor: "darkblue"
        // };

        // this example create an empty JS object and add values into it

        // const person2 = {};

        // person2.firstnName = "John"
        // person2.lastName = "Doe"
        // person2.age = 23
        // person2.eyeColor = "dark-brown"

        // // NEW KEYWORD

        // const person3 = new Object();

        // person3.firstnName = "James"
        // person3.lastName = "Whiltooth"
        // person3.age = 32
        // person3.eyeColor = "dark-green"

        // accessing the properties

        /*
        objectName.propertyName;
        objectName['propertyName'];
        */

        // JS OBJECT METHODS

        /*
        
        Methods are actions thazt can be performed on the objects

        Methods are function definitions stored as property values

        Objects are containers for properties and methods.
        Properties are named values.
        Methods are functions stored as properties.
        Properties can be primitive values, functions and other objects.

        IMMUTABLE - PRIMITIVE VALUES ARE ALWAYS IMMUTABLE - they are hardcoded and can't be changed

        for example

        var x = 3.14;

        here the value of x can be changed but the values of 3.14 can't be changed.

        */

        // --------------------------------------------------------------------------------------

        // What Does Mutable Mean?
        /* 
           In programming, mutability refers to the ability to change the state or contents of an object after 
           it has been created. An object that can be changed after its creation is called mutable, whereas an 
           object that cannot be changed is called immutable.

           ------------------------------------------------------------------------------------------------------

           JavaScript Objects are Mutable

           In JavaScript, objects are mutable. This means that once you create an object, you can change, add, 
           or delete properties of that object.

           ------------------------------------------------------------------------------------------------------

           Why Mutability is Important?

              ---- Side Effects: If you pass an object to a function and that function modifies the object, those changes 
              will be visible outside the function. This is because objects are passed by reference.

              ---- Performance: Modifying an object is generally more efficient than creating a new object, especially 
              if the object is large or if you need to make many changes.

        */

        // let user = {
        //     name: "Alice",
        //     age: 25
        // };

        // function updatePerson(userObj) {
        //    userObj.age = 30;
        // };

        // updatePerson(user);
        // console.log(user.age);

        // console.log(user);

        /* In this example, the updatePerson function modifies the age property 
           of the person object. Because objects are passed by reference, the 
           change is reflected outside the function. */
        
        // const x = user;

        /* The object x is not a copy of person. The object x is person.

        The object x and the object person share the SAME MEMMORY ADDRESS.*/

        // Change Age in both

        // x.age = 10;

        // Delete

        /* The delete keyword deletes both the value of the property and the property itself.

           After deletion, the property cannot be used before it is added back again. */

        // NESTED OBJECTS

            // myObj = {
            //     name: "John",
            //     age: 30,
            //     myCars: {
            //         car1: "Ford",
            //         car2: "BMW",
            //         car3: "Fiat"
            //     }
            // }

            // myObj.myCars.car2;
        

    // Displaying Object Properties

    // Create an Object

    // const person = {
    //     name: "John",
    //     age: 30,
    //     city: "New York"
    // };

    // Display Properties

    // document.getElementById("demo").innerHTML = person.name + "," + person.age + "," + person.city;

    // // Displaying Object Properties in a loop

    // // let text = "";
    // //     for (let x in person) {
    // //         text += person[x] + " ";
    // //     };

    // // Display the Text
    // document.getElementById("demo").innerHTML = text;

    /*

    You must use person[x] in the loop.

    person.x will not work (Because x is the loop variable).
    
    */

    // Using Object.values()

        // Create an Array
        // const myArray = Object.values(person);

        // // Display the Array
        // document.getElementById("demo").innerHTML = myArray;

    // Using Object.entries()

    // Object.entries() makes it simple to use objects in loops:

    // const fruits = { Bananas: 300, Oranges: 200, Apples: 500 };

    //     let text = "";
    //     for (let [fruit, value] of Object.entries(fruits)) {
    //         text += fruit + ": " + value + "<br>";
    //     }
    
    // Using JSON.stringify()

    /* JavaScript objects can be converted to a string with JSON method JSON.stringify().

       JSON.stringify() is included in JavaScript and supported in all major browsers.

       The result will be a string written in JSON notation:

    ---------{ "name": "John", "age": 50, "city": "New York" } */

        // // Stringify Object
        // let myString = JSON.stringify(person);

        // // Display String
        // document.getElementById("demo").innerHTML = myString;


        // ---------------------------------------------------------------------------------

        // Javascript Object Constructors

        /*
        -- Sometimes we need to create objects of the same type.
        -- to create objects of the same type we use a object constructor function,
        -- it considered a good practice to name constructor functions with uppercase
        first letter.
        */

        // function Flower(type, color, price){
        //     this.typeName = type;
        //     this.flowerColor = color;
        //     this.flowerPrice = price;
        //     this.flowerAvailability = "Available";
        //      // --------------- for giving default values.
        // }

        // in this constructor function, this  has no value.
        // the value of this will become the new object when a new object is created.

        // ---- creating similar objects.

        // const flowerOne = new Flower( 'Rose', 'Red', '40');
        // const flowerTwo = new Flower( 'Lotus', 'Pink', '45');
        // const flowerThree = new Flower( 'Chembaruthi', 'White', '55');

        // console.log(flowerTwo);

        // adding property to an object

        // flowerTwo.terrain = "water"; // the property is added only to flowerTwo and not any other flower objects.

        // console.log(flowerTwo);

        // Flower.discount = 'Available'; // but this won't work
        // console.log(Flower);

        // to add a new property you must add it to the constructor 
        // function prototype.

        // Flower.prototype.discount = "Available";
        // console.log(Flower);

        // CONSTRUCTOR FUNCTION METHODS

        // function Flower(type, color, price){
        //     this.typeName = type;
        //     this.flowerColor = color;
        //     this.flowerPrice = price;
        //     this.flowerAvailability = "Available";
        //     this.sentece = function(){
        //         return this.typeName+ " is " + this.flowerColor;
        //     }
        // };


        // Adding a method to created object is easy.

        // flowerOne.changeName = function(nameType){
        //     this.type = nameType;
        // };

        // console.log(flowerOne);
        // console.log(flowerTwo);

        // -------------------------------------------------------------------------------


        //  Adding a method to a constructor

        // Flower.changeName = function(typeName){
        //     this.type = typeName;
        // }

        // flowerOne.changeName('lily');

        // Flower.prototype.changeName = function(typeName){
        //     this.type = typeName;
        // }

        // flowerTwo.changeName('sunflower');

        // console.log(flowerTwo);

        // console.log(flowerOne);
        

        // var obj1 = new Object();
        // var obj2 = {};
        // var objj3 = Object.create(null); // it needs a template object if there is no template object use null

        // var hero = Object.create(null);
        // //hero.title = "Ironman";
        // Object.defineProperty(hero,"title", {configurable:true, value :"Ironman", writable:true, enumerable:true})
        // console.log(hero.title); //Ironman
        // hero.title = "Iron Monger";
        // console.log(hero.title); // nochange still Ironman ---- whrn it was not writtable and enurable false



        // --- What if i need to change this
        // --- writable - true then it can be modified
        // --- if enurable is false - which is defualt then it can't be iterated.

        // let avenger = {
        //     title:"Ironman",
        //     power:6,
        //     firstnName:"Tony",
        //     lastName:"Stark",
        //     city:"New York"
        // }
        // // for(let prop in avenger){
        // //     console.log(prop)
        // // }

        // for(let prop in hero){
        //     console.log(prop);
        // }

        // Object.defineProperty(hero,"title", { value :"Hulk", writable:false, enumerable:false}) // non writtable and non dicoverable
        // console.log(hero.title); //??
        // hero.title = "Joker";
        // console.log(hero.title); // ??

        // for(let prop in hero){
        //     console.log(prop)
        // };
        // console.log("###############");

        // it says it can't be redefined

        // use configarable

        // Object.defineProperty


        // ==============================================================================================

        // ------------------------------------OBJECTS ADVANCED------------------------------------------


        // Methods for Defining JavaScript Objects


        // Using an Object Literal

        // ---- An object literal is a list of property names:values inside curly braces {}.

        {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};

// ----------------------------------------------------------------------------------------

    // Using the new Keyword

    // Create an Object

    const person = {};

    // Add Properties
    person.firstName = "John";
    person.lastName = "Doe";
    person.age = 50;
    person.eyeColor = "blue";

    // Create an Object
    const person = new Object();

    // Add Properties
    person.firstName = "John";
    person.lastName = "Doe";
    person.age = 50;
    person.eyeColor = "blue";


// -------------------------------------------------------------------------------------------------------------



    // Using an Object Constructor

// function Person(first, last, age, eyecolor) {
//   this.firstName = first;
//   this.lastName = last;
//   this.age = age;
//   this.eyeColor = eyecolor;
//   this.nationality = "English";
// }


// -------------------------------------------------------------------------------------------------------------
// Using Object.assign()
// Using Object.create()
// Using Object.fromEnties()

// --------------------------------------------------------------------------------------------------------------

// Javascript Object Methods

// 1. GERNERAL METHODS

// Copies properties from a source object to a target object
Object.assign(target, source)

// Creates an object from an existing object
Object.create(object)

// Returns an array of the key/value pairs of an object
Object.entries(object)

// Creates an object from a list of keys/values
Object.fromEntries()

// Returns an array of the keys of an object
Object.keys(object)

// Returns an array of the property values of an object
Object.values(object)

// Groups object elements according to a function
Object.groupBy(object, callback)

// ------------------------------------------------------------------------------------------------

// 2. PROPERY MANAGEMENT METHODS

// Adding or changing an object property
Object.defineProperty(object, property, descriptor)

// Adding or changing object properties
Object.defineProperties(object, descriptors)

// Accessing a Property
Object.getOwnPropertyDescriptor(object, property)

// Accessing Properties
Object.getOwnPropertyDescriptors(object)

// Returns all properties as an array
Object.getOwnPropertyNames(object)

// Accessing the prototype
Object.getPrototypeOf(object)

// 3. OBJECT PROTECTION METHODS

// Prevents re-assignment
const car = {type:"Fiat", model:"500", color:"white"};

// Prevents adding object properties
Object.preventExtensions(object)

// Returns true if properties can be added to an object
Object.isExtensible(object)

// Prevents adding and deleting object properties
Object.seal(object)

// Returns true if object is sealed
Object.isSealed(object)

// Prevents any changes to an object
Object.freeze(object)

// Returns true if object is frozen
Object.isFrozen(object)

// ---------------------------------------------------------------------------------------------------------------

// ----- Using const


/*
   The most common way to protect an object from being changed is by using the const keyword.

    With const you can not re-assign the object, but you can still change the value of a property, 
    delete a property or create a new property.

*/
        




        


    </script>
</head>
<body>
    
</body>
</html>